# 指针

## 取地址运算

- `sizeof` 给出某个类型或变量在内存中占的字节数

### 运算符`&`

- `scanf("%d", &i);`
- `printf("%p\n", &i);`
  - 获得变量的地址，它的操作数必须是变量
  - 地址的大小是否与 int 相同取决于编译器
  - 不能对没有地址的取地址
  - 连续两个变量，地址紧挨，中间相差**变量类型**占得字节，先定义的在更低的位置（堆栈，自顶向下）
  - 数组：`&a` <\==> `a` <\==> `&a[0]` <\==> `&a[1]-类型长度`

## 指针就是保存地址的变量

- `int* p = &i;` p 是指针
  
- `int* p, q;` <==> `int *p, q;` 都表示 p 是指针，q 是普通变量
  
- 变量的值是内存的地址
  -  普通变量的值是实际的值
  - 指针变量的值是具有实际值的变量的地址

- 作为参数的指针
  - `void f(int *p);`
  - 在被调用的时候得到了某个变量的地址：`int i=0;f(&i);`
  - 在函数里面可以通过这个指针访问外面的`i`

- 访问地址上的变量
  - `*` 是一个单目运算符，用来访问指针的值所表示的地址上的变量
  - 可以做左值也可以做右值
    - `int k = *p;`
    - `*p = k+1;`

## 指针与数组

- 函数参数表中的数组实际上是指针，参数中的 `int a[]` 是指针
  - `sizeof(a) == sizeof(int*)`
  - 但是可以用数组的运算符 `[]` 进行运算
  - 以下四种函数原型是等价的：
    - `int sum(int *ar, int n);`
    - `int sum(int *, int);`
    - `int sum(int ar[], int n);`
    - `int sum(int [], int);`
  
- 数组变量是特殊的指针

  - 数组变量本身表达地址，因此 `int a[10]; int *p = a; //无需用 & 取地址`，但是数组的单元表达的是变量，需要用 `&` 取地址：`a==&a[0];`

  - `[]`运算符可以对数组做，也可以对指针做：`p[0]` <==> `a[0]`
  - `*` 运算符可以对指针做，也可以对数组做：`*a = 25`
  - 数组变量是 `const` 的指针，所以不能被赋值：`int a[]` <==> `int *const a=`...

### 指针与 `const`

- 指针是 `const`

  表示一旦得到了某个变量的地址，不能再指向其他变量

  - `int * const q = &i;// q 是 const`
  - `*q = 26;// OK`
  - `q++;// ERROR`

- 所指是 `const`

  表示不能通过这个指针取修改那个变量（并不能使得那个变量成为 `const` ）

  - `const int *p = &i;` <==> `int const* p = &i;`
  - `*p = 26;// ERROR! (*p) 是 const`
  - `i = 26;// OK`
  - `p = &j;//OK`

#### 转换

- 总是可以把一个非 `const` 的值转换成 `const` 的

  ```c++
  void f(const int* x);// 给一个指针，函数内不会动该指针
  int a = 15;
  f(&a);// OK
  const int b = a;
  
  f(&b);// OK
  b = a + 1;// ERROR!
  ```

- 当要传递的参数的类型比地址大的时候，这是常用的⼿段：既能⽤比较少的字节数传递值给参数，⼜能避免函
  数对外⾯的变量的修改

#### `const` 数组

- `const int a[] = {1,2,3,4,};`
  - 数组变量已经是 `const` 的指针了，这里的 `const` 表明数组的每个单元都是 `const int`
  - 所以必须通过初始化进行赋值
- 保护数组值
  - 因为把数组传入函数时传递的是地址，所以那个函数内部可以修改数组的值
  - 为了保护数组不被函数破坏，可以设置参数为 `const`
    - `int sum(const int a[], int length);`

## 指针计算

- 给⼀个指针加1表⽰要让指针指向下⼀个变量

  - `int a[10]; int *p = a;`
  - `*(p+1) --> a[1]`
  - `*(p+n) <==> a[n]`

- 如果指针不是指向一片连续分配的空间（如数组），则这种运算无意义

- 这些算术运算可以对指针做

  - 给指针加、减一个整数 (+, +=, -, -=)
  - 递增递减 (++/--)
    - `*p++`
      - 取出 `p` 所指的那个数据来，完事之后顺便把 `p` 移到下一个位置
      - `*` 的优先级低于 `++` 
      - 常用于数组类的连续空间操作
      - 在某些 CPU 上，这可以直接被翻译成一条汇编指令
  - 两个指针相减：两指针间有几个元素

- 指针比较

  - `<` `<=` `==` `>` `>=` `!=` 都可以对指针做
  - 比较它们在内存中的地址
  - 数组中的单元的地址肯定是线性递增的

### 0 地址

  - 内存中有 0 地址，但是 0 地址通常是一个不能随便碰的地址
  - 指针不应具有 0 值
  - 因此可以用 0 地址来表示特殊的事情：
    - 返回的指针是无效的
    - 指针没有被真正初始化（先初始化为0）
  - NULL 是一个预定义的符号，表示 0 地址
    - 有的编译器不愿意你用 0 来表示 0 地址


### 指针的类型

- ⽆论指向什么类型，所有的指针的⼤小都是一样的，因为都是地址
- 但是指向不同类型的指针是不能直接互相赋值的
- 这是为了避免用错指针

#### 指针的类型转换

- `void*` 表示不知道指向什么东西的指针
  - 计算时与 `char*` 相同，但不相通
- 指针也可转换类型
  - `int *p = &i; void *p = (void*)p;`
- 这并没有改变 `p` 所指的变量的类型，而是让后人用不同的眼光通过 `p` 看它所指的变量
  - 不再认为是 `int` ，而是 `void`

## 应用场景

- 交换两个变量的值

  ```c++
  void swap(int *pa, int *pd) {
      int t = *pa;
      *pa = *pb;
      *pb = t;
  }
  ```
  
- 函数返回多个值
  
- 传入的参数实际上是需要保存带回的结果的变量
  
- 函数返回运算的状态，结果通过指针返回

  - 常用套路：函数返回特殊的不属于有效范围内值表示出错，如“

    - `-1` 或 `0` （文件操作中有大量例子）

    - 但当任何数值都是有效的可能结果时，就得分开返回

      ```c++
      #include <stdio.h>
      
      /*
          @return 如果除法成功，返回1，否则返回0
      */
      int divide(int a, int b, int *result);
      
      int main() {
          int a=5;
          int b=2;
          int c;
          if (divide(a,b,&c)) {
              printf("%d/%d=%d\n", a, b, c);
          }
          return 0;
      }
      
      int divide(int a, int b, int *result) {
          int ret =1;
          if (b==0) ret = 0;
          else {
              *result = a/b;
          }
          return ret;
      }
      ```

    - 后续的语言（C++, Java）采用了异常机制来解决这个问题
  
- 需要传入较大的数据时用作参数

- 传入数组后对数组做操作

- 函数返回不止一个结果

- 需要函数来修改不止一个变量

- 动态申请的内存...

## 动态内存分配

### 输入数据

- 如果输入数据，先告诉个数，再输入，要纪录每个数据
- C99 可以用变量做数组定义的大小，那么 C99 之前呢
  - 动态内存分配：`int *a = (int*)malloc(n*sizeof(int));`

### `malloc`

`#include <stdlib.h>`
`void * malloc(size_t size);`

```c++
#include <stdio.h>
#include <stdlib.h>

int main(void) {
    int number;
    int* a;
    int i;
    
    printf("输入数量：");
    scanf("%d", &number);
    //int a[number];
    a = (int*)malloc(number*sizeof(int));// (int*) 强制转换为整型指针
    for (i=0; i<number; i++) {
        scanf("%d", &a[i]);
    }
    for (i=number-1; i>=0; i--) {
        printf("%d ", a[i]);
    }
    
    free(a);// 释放
    
    return 0;
}
```

- 向 `malloc` 申请的空间大小是以字节为单位的返回的结果是 `void*`，需要类型转换为自己需要的类型
  - `(int*)malloc(n*sizeof(int));`

### 没空间了

如果申请失败则返回 0，或者叫做 NULL

### `free()`

- 把申请来的空间还给“系统”
- 申请过的空间，最终都应该要还
- 只能还申请来的空间的首地址

#### 常见问题

- 申请了没 free --> 长时间运行内存逐渐下降
  - 新手：忘了
  - 老手：找不到合适的 free 时机
- free 过了再 free
- 地址变过了，直接去 free

## 函数之间传递指针

### 好的模式

- 如果程序中要用到动态分配的内存并且会在函数之间传递，不要让函数申请内存后返回给调用者
- 因为十有⼋九调⽤者会忘了 free，或找不到合适的时机来 free
- 好的模式是让调⽤者⾃己申请，传地址进函数，函数再返回这个地址出来
- :exclamation: 除⾮函数的作⽤就是分配空间，否则不要在函数中 `malloc` 然后传出去⽤

### 函数返回指针？

- 返回指针没问题，关键是谁的地址
  - 本地变量（包括参数）：函数离开后这些变量就不存在了，指针所指的是不能⽤的内存
  - 传⼊入的指针：没问题
  - 动态申请的内存：没问题
  - 全局变量 ？（待解释

## 常见错误

定义了指针变量，还没有指向任何变量，就开始使⽤指针

