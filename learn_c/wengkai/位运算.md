# 按位运算

将整数当作二进制来计算

- C 有这些按位运算的运算符

| 运算符 |          作用           |
| :----: | :---------------------: |
|  `&`   | [按位的与](#按位与 `&`) |
|  `|`   |  [按位的或](#按位或 `|`)  |
|  `~`   |       [按位的取反](#按位取反 `~`)       |
|  `^`   |       [按位的异或](#按位异或 `^`)       |
|  `<<`  |          [左移](#左移 `<<`)          |
|  `>>`  |          [右移](#右移 `>>`)          |

## 按位与 `&`

- 如果 $(x)_i == 1$ 而且 $(y)_i==1$，那么 $(x \& y)_i=1$
- 否则的话 $(x\&y)_i=0$
- 按位与常用于两种应用：
    - 让某一位或某些位为 0：`x & 0xFE`
    - 取一个数中的一段：`x & 0xFF`

## 按位或 `|`

- 如果 $(X)_i==1$ 或 $(y)_i==1$ ，那么 $(x\ |\ y)_i=1$
- 否则的话，$(x\ |\ y)_i=0$
- 按位或常用于两种应用：
    - 使得一位或几个位为 1：`x|0x01`
    - 把两个数拼起来：`0x00FF|0xFF00`

## 按位取反 `~`

- $(~x)_i=1-(x)_i$
- 把 1 位变 0，0 位变 1
- 想得到全部位为 1 的数：`~0`
- 7 的二进制是`0111`， `x|7` 使得低 3 位为 1
- `x&~7`，就使得低 3 位为 0

## 按位异或 `^`

- 如果 $(x)_i==(y)_i$，那么 $(x ^ y)_i=0$
- 否则的话，$(x^y)_i == 1$
- 如果两个位相等，那么结果为 0；不相等，结果为 1
- 如果 `x` 和 `y`，那么  `x^y` 的结果为 0
- 对一个变量用一个值异或两次，等于什么也没做
    - `x^y^y` -- > `x`

## 逻辑运算 vs 按位运算

- 对于逻辑运算，它只看到两个值：0 和 1
- 可以认为逻辑运算相当于把所有非 0 值都变成 1，然后做按位运算
    - `5 & 4` --> `4` 而 `5 && 4` —> `1 & 1` —> `1`
    - `5 | 4` --> `5` 而 `5 || 4` --> `1 | 1` --> `1`
    - `~4 —> 3` 而 `!4` --> `!1` --> `0`

# 移位运算

## 左移 `<<`

- $i<<j$
- `i` 中所有的位向左移动 `j` 个位置，而右边填入 0
- 所有小于 int 的类型，位移以 int 的方式来做，结果是 int
- $x<<=1$ 等价于 $x*=2$
- $x<<=n$ 等价于 $x*=2^n$

## 右移 `>>`

- $i<<j$
- `i` 中所有的位向右移动 `j` 个位置
- 所有小于 int 的类型，位移以 int 的方式来做，结果是 int
- 对于  的类型，左边填入 0
- 对于  的类型，左边填入原来的最高位（保持符号不变）
- $x<<=1$ 等价于 $x/=2$
- $x<<=n$ 等价于 $x/=2^n$

## NOTICE

- 移位的位数不要用负数，这是没有定义的行为

    `x << -2// NO!`
# 位运算例子

## 输出一个数的二进制

```c
#include <stdio.h>

int main(int argc, char const *argv[]) {
    int number;
    scanf("%d", &number);
    unsigned mask = lu<<31;
    for (; mask; mask>>=1) {
        printf("%d", number & mask?1:0);
    }
    printf("\n");
    
    return 0;
}
```



在单片机上也有应用

# 位段

- 把一个 int 的若干位组合成一个结构

    ```c
    struct {
        unsigned int leading : 3;
        unsigned int FLAG1 : 1;
        unsigned int FLAG2 : 1;
        int trailing: 11;
    };
    ```

- 可以直接用位段的成员名称来访问
    - 比移位、与、或还方便
- 编译器会安排其中的位的排列，不具有可移植性
- 当所需的位超过一个 int 是会采用多个 int