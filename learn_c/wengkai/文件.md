> 本周是关于C语言如何做文件和底层操作的。
>
> 文件操作，从根本上说，和C语言无关。这部分的内容，是教你如何使用C语言的标准库所提供的一系列函数来操作文件，最基本的最原始的文件操作。你需要理解，我们在这部分所学习的，是函数库的使用，而非C语言。顺便我们还学习了很多和计算机相关的知识，比如重定向、文本文件和二进制文件的江湖恩怨。但是既然不是C语言，也就意味着你将来的工业环境下，未必还会使用这么原始的文件操作函数了。这些函数，只是一个标本，让你知道可以这样来操纵文件。但是，不见得所有的库都是以这样的方式来操纵文件的。
>
> 围绕文件操作，还有一个C语言受时代局限，处理得不够好的东西，就是错误处理。因为文件操作的每一个步骤都很可能在实行过程中遇到问题：文件打不开啦，读了一半出错啦，等等等等，所以设计文件操作函数如何反馈和处理这类运行时刻的问题是需要很好的手段的。C的这个函数库，主要是通过特殊的返回值来实现的。后来的语言，如C++和Java，则引入了异常机制来处理这些事情。
>
> 关于底层操作，我们主要是介绍了按位操作，包括按位的运算、移位和位段。这些操作在日常程序中难得遇到，主要是用于接触硬件的底层程序的。这些内容在本课程是选读的。

# 格式化的输入输出

- `printf`
    - [`%[flags][width][.prec][hlL]type`](#`%[flags][width][.prec][hlL]type`)
- `scanf`
    - [`%[flag]type`](#`%[flag]type`)

## `%[flags][width][.prec][hlL]type`

|  `Flag`   |        含义         |
| :-------: | :-----------------: |
|    `-`    |       左对齐        |
|    `+`    | 在前面放 `+` 或 `-` |
| `(space)` |      正数留空       |
|    `0`    |      `0` 填充       |

| `width` 或 `prec` |            含义            |
| :---------------: | :------------------------: |
|     `number`      |          最小字符          |
|        `*`        |     下一个参数是字符数     |
|     `.number`     |       小数点后的位数       |
|       `.*`        | 下一个参数是小数点后的位数 |

| 类型修饰 |    han yi     |
| :------: | :-----------: |
|   `hh`   |   单个字节    |
|   `h`    |    `short`    |
|   `l`    |    `long`     |
|   `ll`   |  `long long`  |
|   `L`    | `long double` |

|   `type`   |        用于        |   `type`   |       用于       |
| :--------: | :----------------: | :--------: | :--------------: |
| `i` or`d`  |       `int`        |    `g`     |     `float`      |
|    `u`     |   `unsigned int`   |    `G`     |     `float`      |
|    `o`     |       八进制       | `a` or `A` |   十六进制浮点   |
|    `x`     |      十六进制      |    `c`     |      `char`      |
|    `X`     | 字母大写的十六进制 |    `s`     |      字符串      |
| `f` or `F` |    `float`, `6`    |    `p`     |       指针       |
| `e` or`E`  |        指数        |    `n`     | 读入／写出的个数 |

## `%[flag]type`

| `flag` |       含义       |
| :----: | :--------------: |
|  `*`   |       跳过       |
|  数字  |    最大字符数    |
|  `hh`  |      `char`      |
|  `h`   |     `short`      |
|  `l`   | `long`, `double` |
|  `ll`  |   `long long`    |
|  `L`   |  `long double`   |

|     `type`     |            用于            |       `type`       |     用于     |
| :------------: | :------------------------: | :----------------: | :----------: |
|      `d`       |           `int`            | `a`, `e`, `f`, `g` |   `float`    |
|      `i`       | 整数，可能十六进制或八进制 |        `c`         |    `char`    |
|      `u`       |       `unsigned int`       |        `o`         |    字符串    |
|      `o`       |           八进制           |        `x`         | 所允许的字符 |
| [`[…]`](#[^.]) |          十六进制          |        `p`         |     指针     |

## `[^.]`

- `//$GPRMC,004319.00,A,3016.98468,N,12006.39211,E,0.047,,130909,,,D*79`
- `scanf("%*[^,],%[^,],%[^,],%[^,],%[^,],%[^,],%[^,],%[^,],%[^,],%[^,]",sTime,sAV,sLati,&sNW,sLong,&sEW,sSpeed,sAngle,sDate);`

## `printf` 和 `scanf` 的返回值

- 读入的项目数
- 输出的字符数

- 在要求严格的程序中应该判断每次调用 `scanf` 或 `printf` 的返回值，从而了解程序运行中是否存在问题

# 文件的输入输出

- 用 `<` 和 `>` 做重定向

    ```shell
    MacBook-Pro:tryToExperiment s$ ./test > 12.out
    12345
    MacBook-Pro:tryToExperiment s$ more 12.out
    12345
    MacBook-Pro:tryToExperiment s$ cat > 12.in
    1234
    MacBook-Pro:tryToExperiment s$ more 12.in
    1234
    MacBook-Pro:tryToExperiment s$ ./test < 12.in
    1234
    MacBook-Pro:tryToExperiment s$ ./test < 12.in > 12.out
    MacBook-Pro:tryToExperiment s$ more 12.out
    1234
    ```

## 输入结束

- `getchat` 读到了 `EOF`
- `scanf` 返回小于要求读的数量

## `FILE`

- `FILE* fopen(const char * restrict path, const char * restrict mode);`
- `int fclose(FILE *stream);`
- `fscanf(FILE*, ...);`
- `fprintf(FILE*, ...);`

## 打开文件的标准代码

```c
FILE* fp = fopen("file", "r");
if (fp) {
    fscanf(fp, ...);
    fclose(fp);
} else{
    //...
}
```

## `fopen`

| `fp`  |                        作用                        |
| :---: | :------------------------------------------------: |
|  `r`  |                      打开只读                      |
| `r+`  |               打开读写，从文件头开始               |
|  `w`  |     打开只写。如果不存在则新建，如果存在则清空     |
| `w+`  |     打开读写。如果不存在则新建，如果存在则清空     |
|  `a`  | 打开追加。如果不存在则新建，如果存在则从文件尾开始 |
| `..x` |          只新建，如果文件已存在则不能打开          |

# 二进制文件

- 其实所有的文件最终都是二进制的
- 文本文件无非是用最简单的方式可以读写的文件
    - `more`, `tail`
    - `cat`
    - `vi`
- 而二进制文件是需要专门的程序来读写的文件
- 文本文件的输入输出是格式化，可能经过转码

## 文本 vs 二进制

- Unix 喜欢用文本文件来做数据存储和程序配置
    - 交互式终端的出现使得人们喜欢用文本和计算机“talk”
    - Unix 的 shell 提供了一些读写文本的小程序
- Windows 喜欢用二进制文件
    - DOS 是草根文化，并不继承和熟悉 Unix 文化
    - PC 刚开始的时候能力有限，DOS 的能力更有限，二进制更接近底层
- 文本
    - 优势是方便人类读写，而且跨平台
    - 缺点是程序输入输出要经过格式化，开销大
- 二进制
    - 优势是程序读写快
    - 缺点是人类读写困难，而且不跨平台。如 int 的大小不一致，大小端的问题

## 程序为什么要文件

- 配置
    - Unix 用文本，Windows 用注册表
- 数据
    - 稍微有点量的数据都放数据库了
- 媒体
    - 只能二进制

现实是，程序通过第三方库来读写文件，很少直接读写二进制文件

## 二进制读写

- `size_t fread(void *restrict ptr, size_t size, size_t nitems, FILE *restrict stream);`
- `size_t fwrite(const void *restrict ptr, size_t size, size_t nitems, FILE *restrict stream);`
- 注意 `FILE` 指针是最后一个参数
- 返回的是成功读写的字节数

## 为什么 `nitem`

- 因为二进制文件的读写一般是通过一个结构变量的操作来进行的
- 于是 `nitem` 就是用来说明这次读写几个结构变量

## 在文件中定位

- `long ftell(FILE *stream);`
- `int fseek(FILE *stream, long offset, int whence);`
    - `SEEK_SET`: 从头开始
    - `SEEK_CUR`: 从当前位置开始
    - `SEEK_END`: 从尾开始（倒过来）

## 可移植性

- 这样的二进制文件不具有可移植性
    - 在 int 为 32 位的机器上写成的数据文件无法直接在 int 为 64 位的机器上正确读出
- 解决方案之一是放弃使用 int，而是 typedef 具有明确大小的类型
- 更好的方案是用文本